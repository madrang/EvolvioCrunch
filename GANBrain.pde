class GANBrain {
  //ie The Dreaming Brain.
  //If Brain V1 was an ant, this is a goldfish (Fish can sleep).
  //https://www.cuteness.com/blog/content/do-goldfish-sleep
  
  //2 Neural network, 1 GAN and a constantly evolving network.
  //The first network should be an self generating networks where nodes live in a hashmap in an positionned plane(IE each nodes has pos.x pos.y and can move towards the other nodes of interest).
  //By being localised, like in a normal brain, this will induce function clusters where simmilar fonctions comes toghter and may merge to form a more complex and more interconnected network.
  // This would test my theory that locallity does have an effect on backpropagation and the formation of new links. The current formula W(i) = W(i) + [ T - A ] * P(i)
  // For all inputs i : W(i) = W(i) + [ T - A ] * P(i)
  // W is the vector of weights,
  // P is the input vector presented to the network,
  // T is the correct result that the neuron should have shown,
  // A is the actual output of the neuron,
  // This formula should take in account the distance from the firing neuron and periodicity.
  // Neurons that fire in simmillar paterns at the same time may have a simmilar or complemental function.
  // This should be implemented as a slow migration of the neurons toward simmilar looking nodes.
  // If the position is pretty much the same(neurons overlaping on xy coodinates.) then we could assume to have a perfect match and fuse them.
  // Over time this process would migrate the neurons toward those that fire before or after and those that sents it signals as they too do trigger closely at the same time, but not always.
  // Then the position in xy space would be close, but never merging.
  
  //The generative adversarial network
  //This neworks in the awake phase will keep track of the most rewarding times the evaluation function was (hsnt, getting rewards triggers backpropagation in GAN).
  //It needs to simulate derivative situations from the awake state of the world. (Ie, all inputs from the HashNet are also sent to the GAN)
  //The GAN is only presented with that information (and possibly a little from before / after) only when the fitness function returns a score, positive or negative(a negative result, ie risk of death, would that be a nightmare to relive???).
  
  //When the entorpy gets too high due to addning new neurons and the formation of new links, pruning must be done. Force the network to clean itself.
  
  //When the entropy of the awoke network is too high, it enters sleep mode where it will face a simulated world Generated by it's own GAN.
  //The same fitness function will be applied, with the goal of increasing positive returns and eliminating or reduging negative return.
  // The GAN itself will only have this for it's own score, how much of an improvement could be made by simutaing the proper inputs.
  //Then the entropy need to reduce, also since those in sleep mode do not have to wait for input data updates, they can be updated at a higher rate but more CPU cost.
  //This faster excution in the times of reward or risk simulated situation would bring active nodes to migrate to the proprer place faster.
  //Newly formed links (the one created since last sleep cycle) if they do not trigger/are used in the simulated situations(Simulated Inputs) from the GAN, then they are removed/disconnected as they are useless to improve fitness.
  //Nodes will merge and After entropy is reduced the network can retrun in an operative state.
  //When entropy increases, the percentages of useless node or connexion increases. So as CPU cost...
  //This should allow a network to evolve toward a less compute intensive solution.
  //While allowing the formation of new connexions in the awake state. 
  //https://papers.nips.cc/paper/5423-generative-adversarial-nets.pdf
  
  final String[] inputLabels = {
    "Size",
    "MHue",
  };
  final String[] outputLabels = {
    "BHue",
    "Accel.",
    "Turn",
    "Eat",
    "Fight",
    "Birth",
    "MHue",
  };
  
  int BRAIN_WIDTH;
  int BRAIN_HEIGHT;
  final int BRAIN_STATIC_INPUT_COUNT = 2;
  final int BRAIN_STATIC_OUTPUT_COUNT = 7;
  
  int VISION_INPUT_COUNT;
  int VISION_OUTPUT_COUNT;
  Creature crea;
  
  HashGrid<GANeuron> neurons;
  int maxInterconnectDistance;
  
  public GANBrain(Creature c, int brwidth, int brheight, int mid){
    BRAIN_WIDTH = brwidth;
    BRAIN_HEIGHT = brheight;
    maxInterconnectDistance = mid;
    neurons = new HashGrid<GANeuron>(brwidth, brheight, maxInterconnectDistance);
    
    generateRandomNetwork();
    
    if (c != null) {
      setCreature(c);
    }
  }
  
  public GANBrain(Creature c, int brwidth, int brheight, Set<GANeuron> tbrain, int mid){
    BRAIN_WIDTH = brwidth;
    BRAIN_HEIGHT = brheight;
    maxInterconnectDistance = mid;
    neurons = new HashGrid<GANeuron>(brwidth, brheight, maxInterconnectDistance);
    
    if(tbrain == null){
      generateRandomNetwork();
    }else{
      for(GANeuron nr : tbrain){
        neurons.add(nr);
      }
    }
    
    if (c != null) {
      setCreature(c);
    }
  }
  
  public void generateRandomNetwork() {
    for(int x = 0; x < BRAIN_WIDTH-1; x++){
      for(int y = 0; y < BRAIN_HEIGHT; y++){
        //neurons[x][y] = new Neuron(neurons, BRAIN_HEIGHT, x, y, EvoMath.AXON_START_MUTABILITY);
      }
    }
    for(int x = 0; x < BRAIN_WIDTH; x++){
      for(int y = 0; y < BRAIN_HEIGHT; y++){
        if(x == BRAIN_WIDTH - 1){
          //neurons[x][y] = new Neuron(neurons, BRAIN_HEIGHT);
        }
        if(y == BRAIN_HEIGHT-1){
          //neurons[x][y].output = 1;
        }else{
          //neurons[x][y].output = 0;
        }
      }
    }
  }
  
  public void setCreature(Creature c) {
    if (c == null) {
      throw new AssertionError("Null creature in Brain.");
    }
    crea = c;
    VISION_INPUT_COUNT = crea.vision.visionResults.length;
    VISION_OUTPUT_COUNT = crea.vision.visionAngles.length;
  }
  
  public void useBrain(double timeStep, boolean useOutput){
    //Read Inputs
    for(int y = 0; y < BRAIN_HEIGHT-1; y++){
      //neurons[0][y].output = getInput(y);
    }
    
    //Compute
    for(int x = 1; x < BRAIN_WIDTH; x++){
      //Start at 1 as input nodes no not have inputs/Axons to read.
      //Dont need to update the last row as Const.
      for(int y = 0; y < BRAIN_HEIGHT-1; y++){
        //neurons[x][y].update(x, y);
      }
    }
    
    if(useOutput){
      //Apply outputs.
      int end = BRAIN_WIDTH - 1;
      for(int y = 0; y < BRAIN_HEIGHT-1; y++){
        //applyOutput(y, neurons[end][y].output, timeStep);
      }
    }
  }
  
  public void drawBrain(PFont font, float scaleUp, int mX, int mY){
    final float neuronSize = 0.4;
    noStroke();
    fill(0,0,0.4);
    rect((-1.7 - neuronSize) * scaleUp, -neuronSize  *scaleUp, (2.4 + BRAIN_WIDTH + neuronSize*2) * scaleUp, (BRAIN_HEIGHT + neuronSize*2) * scaleUp);
    
    //Draw Input/Output names.
    ellipseMode(RADIUS);
    strokeWeight(2);
    textFont(font, 0.58 * scaleUp);
    fill(0,0,1);
    for(int y = 0; y < BRAIN_HEIGHT; y++){
        textAlign(RIGHT);
        text(getInputLabel(y), (-neuronSize-0.1) * scaleUp, (y+(neuronSize*0.6)) * scaleUp);
        textAlign(LEFT);
        text(getOutputLabel(y), (BRAIN_WIDTH-1+neuronSize+0.1) * scaleUp, (y+(neuronSize*0.6)) * scaleUp);
    }
    
    //Draw Nodes
    textAlign(CENTER);
    noStroke();
    for(int x = 0; x < BRAIN_WIDTH; x++){
      for(int y = 0; y < BRAIN_HEIGHT; y++){
        //fill(neurons[x][y].neuronFillColor());
        ellipse(x * scaleUp, y * scaleUp, neuronSize * scaleUp, neuronSize * scaleUp);
        
        //fill(neurons[x][y].neuronTextColor());
        //text(nf((float)neurons[x][y].output, 0, 1), x * scaleUp, (y + (neuronSize*0.6)) * scaleUp);
      }
    }
    
    //Draw lines linking neurons(Axons).
    if(mX >= 0 && mX < BRAIN_WIDTH && mY >= 0 && mY < BRAIN_HEIGHT){
      for(int y = 0; y < BRAIN_HEIGHT; y++){
        if(mX >= 1 && mY < BRAIN_HEIGHT-1){
          drawAxon(mX-1,y,mX,mY,scaleUp);
        }
        if(mX < BRAIN_WIDTH-1 && y < BRAIN_HEIGHT-1){
          drawAxon(mX,mY,mX+1,y,scaleUp);
        }
      }
    }
  }
  
  public void drawAxon(int x1, int y1, int x2, int y2, float scaleUp){
    //neurons[x1][y1].drawAxon(x1, y1, x2, y2, scaleUp);
  }
  
  
  public Brain reproduce(ArrayList<Creature> parents){
    int parentsTotal = parents.size();
    
    if (parentsTotal <= 0) {
     return new Brain(null, BRAIN_WIDTH, BRAIN_HEIGHT);
    }
    
    Axon[][][] newBrain = new Axon[BRAIN_WIDTH-1][BRAIN_HEIGHT][BRAIN_HEIGHT-1];
    Neuron[][] newNeurons = new Neuron[BRAIN_WIDTH][BRAIN_HEIGHT];
    float randomParentRotation = random(0,1);
    
    for(int x = 0; x < BRAIN_WIDTH-1; x++){
      for(int y = 0; y < BRAIN_HEIGHT; y++){
        for(int z = 0; z < BRAIN_HEIGHT-1; z++){
          float axonAngle = atan2((y+z)/2.0 - BRAIN_HEIGHT/2.0, x - BRAIN_WIDTH/2)/(2*PI)+PI;
          Creature parentForAxon = parents.get((int)(((axonAngle + randomParentRotation) % 1.0) * parentsTotal));
          newBrain[x][y][z] = parentForAxon.brain.neurons[x][y].axons[z].mutateAxon();
        }
      }
    }
    for(int x = 0; x < BRAIN_WIDTH; x++){
      for(int y = 0; y < BRAIN_HEIGHT; y++){
        float neuronAngle = atan2(y - BRAIN_HEIGHT/2.0, x - BRAIN_WIDTH/2)/(2*PI) + PI;
        Creature parentForNeuron = parents.get((int)(((neuronAngle + randomParentRotation) % 1.0) * parentsTotal));
        newNeurons[x][y] = parentForNeuron.brain.neurons[x][y].mutateNeuron(newNeurons, BRAIN_HEIGHT);
      }
    }
    
    //Copy Axons in nerons.
    for(int x = 0; x < BRAIN_WIDTH; x++){
      for(int y = 0; y < BRAIN_HEIGHT; y++){
        if (x == BRAIN_WIDTH - 1) {
          //Last row are constants.
          continue;
        }
        for(int z = 0; z < BRAIN_HEIGHT-1; z++){
          newNeurons[x][y].axons[z] = newBrain[x][y][z];
        }
      }
    }
    return new Brain(null, BRAIN_WIDTH, BRAIN_HEIGHT, newNeurons);
  }
  
  public double getInput(int i) {
    if (i < VISION_INPUT_COUNT){
      return crea.vision.visionResults[i];
    }
    i -= VISION_INPUT_COUNT;
    switch(i) {
      case 0:
        return crea.energy;
      case 1:
        return crea.mouthHue;
      
      default:
        i -= 2;
    }
    
    return 0;
  }
  
  public String getInputLabel(int i) {
    if (i == BRAIN_HEIGHT - 1) {
     return "Const."; 
    }
    
    if (i < VISION_INPUT_COUNT){
      return crea.vision.getInputLabel(i);
    }
    i -= VISION_INPUT_COUNT;
    
    if (i < BRAIN_STATIC_INPUT_COUNT) {
     return inputLabels[i]; 
    }
    i -= BRAIN_STATIC_INPUT_COUNT;
    
    return "Unkown";
  }
  
  public void applyOutput(int i, double val, double timeStep) {
    if (i < VISION_OUTPUT_COUNT){
      crea.vision.inputAngles[i] = val;
      return;
    }
    i -= VISION_OUTPUT_COUNT;
    
    switch(i) {
      case 0:
        crea.hue = (val + 1) / 2;
        return;
      case 1:
        crea.accelerate(val * 20, timeStep);
        return;
      case 2:
        crea.turn(val * 10, timeStep);
        return;
      case 3:
        if (val > EvoMath.NEURON_OUTPUT_EPSILON || val < -EvoMath.NEURON_OUTPUT_EPSILON) {
          crea.eat(val * 100, timeStep);
        }
        return;
      case 4:
        if (val > EvoMath.NEURON_OUTPUT_EPSILON || val < -EvoMath.NEURON_OUTPUT_EPSILON) {
          crea.fight(val * 100, timeStep);
        }
        return;
      case 5:
        if (val > EvoMath.NEURON_OUTPUT_EPSILON) {
          if(crea.board.year - crea.birthTime >= crea.MATURE_AGE && crea.energy > crea.SAFE_SIZE && crea.board.creatures.size() < crea.board.creatureMaximum){
            crea.reproduce(crea.SAFE_SIZE, timeStep);
          }
        }
        return;
      case 6:
        crea.mouthHue = (val + 1) / 2;
        return;
      default:
        i -= 7;
    }
  }
  
  public String getOutputLabel(int i) {
    if (i == BRAIN_HEIGHT - 1) {
     return "Const."; 
    }
    
    if (i < VISION_OUTPUT_COUNT){
      return crea.vision.getOutputLabel(i);
    }
    i -= VISION_OUTPUT_COUNT;
    
    if (i < BRAIN_STATIC_OUTPUT_COUNT) {
     return outputLabels[i]; 
    }
    i -= BRAIN_STATIC_OUTPUT_COUNT;
    
    return "Unkown";
  }
}
